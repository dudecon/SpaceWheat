class_name BiomeCharacteristics
extends RefCounted

## Loads and provides access to computed biome characteristics.
##
## Characteristics are generated by the continuity sweep test and stored in
## biome_characteristics.json. This class provides runtime access to:
## - max_continuous_dt: The coarsest timestep that maintains continuous evolution
## - dimension: The Hilbert space dimension (2^num_qubits)
## - num_qubits: Number of quantum axes in the biome
## - status: "stable", "limited", or "skipped"

const CHARACTERISTICS_PATH = "res://Core/Biomes/data/biome_characteristics.json"
const DEFAULT_MAX_DT = 0.02  # Default if no characteristics available

static var _data: Dictionary = {}
static var _loaded: bool = false


static func _load_if_needed() -> void:
	"""Load characteristics from JSON if not already loaded."""
	if _loaded:
		return

	var file = FileAccess.open(CHARACTERISTICS_PATH, FileAccess.READ)
	if not file:
		push_warning("BiomeCharacteristics: Could not load %s - using defaults" % CHARACTERISTICS_PATH)
		_loaded = true
		return

	var json = JSON.new()
	var err = json.parse(file.get_as_text())
	file.close()

	if err != OK:
		push_error("BiomeCharacteristics: JSON parse error: %s" % json.get_error_message())
		_loaded = true
		return

	_data = json.data
	_loaded = true

	var biome_count = _data.get("biomes", {}).size()
	print("[BiomeCharacteristics] Loaded characteristics for %d biomes" % biome_count)


static func get_max_continuous_dt(biome_name: String) -> float:
	"""Get the maximum continuous timestep for a biome.

	Returns the coarsest dt that maintains continuous quantum evolution.
	Use this to set max_evolution_dt for optimal performance.
	"""
	_load_if_needed()

	var biomes = _data.get("biomes", {})
	if not biomes.has(biome_name):
		return DEFAULT_MAX_DT

	var biome_data = biomes[biome_name]
	var max_dt = biome_data.get("max_continuous_dt", DEFAULT_MAX_DT)

	# Skipped biomes have min dt as placeholder - use default instead
	if biome_data.get("status") == "skipped":
		return DEFAULT_MAX_DT

	return max_dt


static func get_dimension(biome_name: String) -> int:
	"""Get the Hilbert space dimension for a biome (2^num_qubits)."""
	_load_if_needed()

	var biomes = _data.get("biomes", {})
	if not biomes.has(biome_name):
		return 0

	return biomes[biome_name].get("dimension", 0)


static func get_num_qubits(biome_name: String) -> int:
	"""Get the number of qubits for a biome."""
	_load_if_needed()

	var biomes = _data.get("biomes", {})
	if not biomes.has(biome_name):
		return 0

	return biomes[biome_name].get("num_qubits", 0)


static func get_status(biome_name: String) -> String:
	"""Get the characterization status: 'stable', 'limited', or 'skipped'."""
	_load_if_needed()

	var biomes = _data.get("biomes", {})
	if not biomes.has(biome_name):
		return "unknown"

	return biomes[biome_name].get("status", "unknown")


static func get_all_characteristics(biome_name: String) -> Dictionary:
	"""Get all characteristics for a biome."""
	_load_if_needed()

	var biomes = _data.get("biomes", {})
	if not biomes.has(biome_name):
		return {}

	return biomes[biome_name].duplicate()


static func get_metadata() -> Dictionary:
	"""Get the metadata about when/how characteristics were generated."""
	_load_if_needed()
	return _data.get("_metadata", {}).duplicate()


static func is_loaded() -> bool:
	"""Check if characteristics have been loaded."""
	return _loaded


static func reload() -> void:
	"""Force reload characteristics from disk."""
	_loaded = false
	_data = {}
	_load_if_needed()


static func get_all_biome_names() -> Array:
	"""Get list of all biome names with characteristics."""
	_load_if_needed()
	return _data.get("biomes", {}).keys()


static func get_biomes_by_status(status: String) -> Array:
	"""Get list of biomes with a specific status."""
	_load_if_needed()

	var result: Array = []
	var biomes = _data.get("biomes", {})

	for biome_name in biomes:
		if biomes[biome_name].get("status") == status:
			result.append(biome_name)

	return result


static func apply_to_biome(biome) -> void:
	"""Apply optimal max_evolution_dt to a biome based on characteristics.

	Call this after building a biome to set its evolution granularity
	to the optimal value determined by the continuity sweep.
	"""
	if biome == null:
		return

	var biome_name = ""
	if biome.has_method("get_biome_type"):
		biome_name = biome.get_biome_type()
	elif "name" in biome:
		biome_name = biome.name

	if biome_name.is_empty():
		return

	var optimal_dt = get_max_continuous_dt(biome_name)

	if "max_evolution_dt" in biome:
		biome.max_evolution_dt = optimal_dt
		print("[BiomeCharacteristics] Set %s.max_evolution_dt = %.6f" % [biome_name, optimal_dt])
