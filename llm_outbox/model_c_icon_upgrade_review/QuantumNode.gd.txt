class_name QuantumNode
extends RefCounted

## Quantum Node - Force-Directed Graph Representation
## Represents a single quantum state in the central force-directed visualization

# Import dependencies
const FarmPlot = preload("res://Core/GameMechanics/FarmPlot.gd")

# Physics state
var position: Vector2 = Vector2.ZERO
var velocity: Vector2 = Vector2.ZERO
var classical_anchor: Vector2 = Vector2.ZERO  # Position of classical plot (tether target)

# Quantum state reference
var plot: FarmPlot = null  # Reference to the actual quantum plot
var plot_id: String = ""
var grid_position: Vector2i = Vector2i.ZERO

# Visual properties (derived from quantum state)
var energy: float = 0.0
var coherence: float = 1.0
var color: Color = Color.WHITE
var radius: float = 20.0
var berry_phase: float = 0.0  # Accumulated quantum evolution (experience points)

# DUAL EMOJI SYSTEM for quantum superposition visualization
var emoji_north: String = "ğŸŒ¾"  # North pole emoji (e.g., ğŸŒ¾ for wheat)
var emoji_south: String = "ğŸ‘¥"  # South pole emoji (e.g., ğŸ‘¥ for wheat)
var emoji_north_opacity: float = 1.0  # Probability-weighted opacity
var emoji_south_opacity: float = 0.0  # Probability-weighted opacity

# Parametric biome coordinates (for auto-scaling layout)
# Position is computed by BiomeLayoutCalculator from these coords
var biome_name: String = ""        # Which biome this node belongs to
var parametric_t: float = 0.5      # Angular parameter [0, 1] around biome oval
var parametric_ring: float = 0.5   # Radial parameter [0, 1] (0=center, 1=edge)

# Farm plot tethering
# When true, this bubble is attached to a farm plot and should show tether lines
# When false, this is a free-floating biome bubble (no tether)
var has_farm_tether: bool = false

# Legacy compatibility (deprecated - use biome_name + parametric coords)
var venn_zone: int = -1      # Zone enum value (-1 = not set)

# Animation properties
var visual_scale: float = 0.0  # Animated scale (0 to 1)
var visual_alpha: float = 0.0  # Animated alpha (0 to 1)
var spawn_time: float = 0.0    # Time when node was created
var is_spawning: bool = false  # Currently animating in

# Constants
const MIN_RADIUS = 10.0
const MAX_RADIUS = 40.0
const SPAWN_DURATION = 0.5  # Fade-in duration in seconds


func _init(wheat_plot: FarmPlot, anchor_pos: Vector2, grid_pos: Vector2i, center_pos: Vector2 = Vector2.ZERO):
	plot = wheat_plot
	classical_anchor = anchor_pos
	grid_position = grid_pos

	# Start at the tether location (where the classical plot is)
	position = anchor_pos

	# Initialize visual scale and alpha to 1.0 (visible immediately)
	visual_scale = 1.0
	visual_alpha = 1.0

	if plot:
		plot_id = plot.plot_id
		update_from_quantum_state()

	# Start empty - no emoji displayed until plot is planted
	emoji_north_opacity = 0.0
	emoji_south_opacity = 0.0


func start_spawn_animation(current_time: float):
	"""Start the spawn animation for this node"""
	is_spawning = true
	spawn_time = current_time
	visual_scale = 0.0
	visual_alpha = 0.0


func update_animation(current_time: float, delta: float):
	"""Update spawn animation"""
	if not is_spawning:
		visual_scale = 1.0
		visual_alpha = 1.0
		return

	var elapsed = current_time - spawn_time
	var progress = clamp(elapsed / SPAWN_DURATION, 0.0, 1.0)

	# Ease-out cubic for smooth deceleration
	var eased = 1.0 - pow(1.0 - progress, 3.0)

	visual_scale = eased
	visual_alpha = eased

	if progress >= 1.0:
		is_spawning = false
		visual_scale = 1.0
		visual_alpha = 1.0


func update_from_quantum_state():
	"""Update visual properties from quantum state (Model C: queries parent_biome.bath)

	Visual mapping (no duplicates):
	- Emoji opacity â† Normalized probabilities (Î¸-like, measurement outcome)
	- Color hue â† Coherence phase arg(Ï_{n,s}) (Ï†-like, quantum phase)
	- Color saturation â† Coherence magnitude (quantum vs classical)
	- Glow (energy) â† Purity Tr(ÏÂ²) (pure=bright, mixed=dim)
	- Pulse rate (coherence) â† |Ï_{n,s}| coherence magnitude (decoherence threat)
	- Radius â† Mass P(n)+P(s) (probability in measurement subspace)
	"""
	var is_transitioning_planted = (radius == MAX_RADIUS)

	# Guard: unplanted or no bath connection â†’ invisible
	if not plot or not plot.is_planted or plot.bath_subplot_id < 0:
		energy = 0.0
		coherence = 1.0
		radius = MIN_RADIUS
		color = Color(0.5, 0.5, 0.5, 0.0)  # Transparent
		emoji_north_opacity = 0.0
		emoji_south_opacity = 0.0
		visual_scale = 0.0
		visual_alpha = 0.0
		return

	# Guard: no parent_biome or no bath â†’ fallback visualization
	if not plot.parent_biome or not plot.parent_biome.bath:
		energy = 1.0
		coherence = 0.5
		radius = MAX_RADIUS
		color = Color(0.7, 0.8, 0.9, 0.8)
		var emojis = plot.get_plot_emojis()
		emoji_north = emojis["north"]
		emoji_south = emojis["south"]
		emoji_north_opacity = 0.5
		emoji_south_opacity = 0.5
		return

	# === QUERY BATH FOR REAL QUANTUM DATA ===
	var bath = plot.parent_biome.bath
	var emojis = plot.get_plot_emojis()
	emoji_north = emojis["north"]
	emoji_south = emojis["south"]

	# 1. EMOJI OPACITY â† Normalized probabilities (Î¸-like)
	var north_prob = bath.get_probability(emoji_north)
	var south_prob = bath.get_probability(emoji_south)
	var mass = north_prob + south_prob  # Total probability in our subspace

	if mass > 0.001:
		emoji_north_opacity = north_prob / mass
		emoji_south_opacity = south_prob / mass
	else:
		# No probability in our subspace - show dim
		emoji_north_opacity = 0.1
		emoji_south_opacity = 0.1

	# 2. COLOR HUE â† Coherence phase arg(Ï_{n,s}) (Ï†-like)
	var coh = bath.get_coherence(emoji_north, emoji_south)
	var coh_magnitude = 0.0
	var coh_phase = 0.0
	if coh:
		coh_magnitude = coh.abs()
		coh_phase = coh.arg()  # Returns angle in radians [-Ï€, Ï€]

	# Map phase to hue [0, 1] for HSV color
	var hue = (coh_phase + PI) / TAU  # Normalize to [0, 1]
	var saturation = coh_magnitude  # More coherent = more saturated color
	color = Color.from_hsv(hue, saturation * 0.8, 0.9, 0.8)

	# 3. GLOW (energy) â† Purity Tr(ÏÂ²)
	# Pure state = 1.0 (bright glow), maximally mixed = 1/N (dim)
	energy = bath.get_purity()

	# 4. PULSE RATE (coherence) â† |Ï_{n,s}| coherence magnitude
	# High coherence = stable/slow pulse, low = jittery/fast
	coherence = coh_magnitude

	# 5. RADIUS â† Mass in subspace (bigger = more probability)
	radius = lerpf(MIN_RADIUS, MAX_RADIUS, clampf(mass * 2.0, 0.0, 1.0))

	# 6. Berry phase accumulation (tracks total evolution)
	berry_phase += energy * 0.01

	if is_transitioning_planted:
		print("âš›ï¸  Node %s: Î¸=(%.2f/%.2f) Ï†=%.1fÂ° purity=%.3f |coh|=%.3f mass=%.3f" % [
			grid_position, emoji_north_opacity, emoji_south_opacity,
			rad_to_deg(coh_phase), energy, coh_magnitude, mass])


func get_entangled_partner_ids() -> Array:
	"""Get list of plot IDs this node is entangled with (Model B: via parent biome)"""
	# Model B: entanglement managed by biome's quantum_computer
	# For now, return empty array - will be implemented via biome queries
	if not plot or not plot.parent_biome:
		return []

	# TODO: Query biome's quantum_computer for entangled registers
	# var partner_ids = []
	# for reg_id in plot.parent_biome.quantum_computer.get_entangled_registers(plot.register_id):
	#     partner_ids.append(...)
	# return partner_ids

	return []  # Empty for now - Model B visualization TODO


func apply_force(force: Vector2, delta: float):
	"""Apply a force to this node"""
	velocity += force * delta


func apply_damping(damping_factor: float):
	"""Apply velocity damping"""
	velocity *= damping_factor


func update_position(delta: float):
	"""Update position from velocity"""
	position += velocity * delta


func get_glow_alpha() -> float:
	"""Get glow halo alpha based on ENERGY + BERRY PHASE

	Glow components:
	- Energy: Current quantum energy level (0.0-0.4)
	- Berry phase: Accumulated evolution (unbounded - grows indefinitely)

	The glow intensifies with quantum evolution history, acting as a
	visual "measurement apparatus" showing full quantum activity.
	Highly evolved bubbles will have intense glows.

	Strong glow = high energy + extensive quantum evolution
	Faint glow = low energy, fresh qubit
	"""
	var energy_glow = energy * 0.4  # 0.0 to 0.4 range
	var berry_glow = berry_phase * 0.2  # Unbounded, grows with evolution
	return energy_glow + berry_glow  # Energy baseline + accumulated evolution


func get_berry_phase_glow() -> float:
	"""Get glow contribution from berry phase (experience/evolution indicator)

	Raw unbounded value that grows indefinitely with quantum evolution.
	This represents the full "measurement apparatus" aesthetic - showing
	every bit of quantum activity with intense visual feedback.

	The more evolved a quantum state is, the brighter it glows.
	Range: Unlimited (0.0 at fresh qubit, increases with evolution)
	"""
	return berry_phase * 0.2


func get_pulse_rate() -> float:
	"""Get pulse/oscillation speed based on COHERENCE

	Fast pulse = high decoherence threat (low coherence)
	Slow pulse = stable coherent state (high coherence)

	Inverted relationship: pulse_rate = 1.0 - coherence
	Range: 0.2 to 2.0 (fast when incoherent, slow when coherent)
	"""
	var decoherence_threat = 1.0 - coherence  # Invert: high coherence = low pulse
	return 0.2 + (decoherence_threat * 1.8)  # Range 0.2 (stable) to 2.0 (chaotic)
