class_name MarketBiome
extends "res://Core/Environment/BiomeBase.gd"

## Quantum Market Biome v2: Emergent Exchange Economics (Icon-Based)
##
## Architecture: Icon-based QuantumBath with 3-qubit tensor product core
##
## Core Market State (8D):
##   Qubit 0 (Sentiment): ğŸ‚ Bull / ğŸ» Bear
##   Qubit 1 (Liquidity): ğŸ’° Money / ğŸ’³ Debt
##   Qubit 2 (Stability): ğŸ›ï¸ Order / ğŸšï¸ Chaos
##
## Basis States (tensor product, 3-char emoji labels):
##   |000âŸ© = "ğŸ‚ğŸ’°ğŸ›ï¸" (Bull + Money + Stable) - best market
##   |001âŸ© = "ğŸ‚ğŸ’°ğŸšï¸" (Bull + Money + Chaos)
##   |010âŸ© = "ğŸ‚ğŸ’³ğŸ›ï¸" (Bull + Debt + Stable)
##   |011âŸ© = "ğŸ‚ğŸ’³ğŸšï¸" (Bull + Debt + Chaos)
##   |100âŸ© = "ğŸ»ğŸ’°ğŸ›ï¸" (Bear + Money + Stable)
##   |101âŸ© = "ğŸ»ğŸ’°ğŸšï¸" (Bear + Money + Chaos)
##   |110âŸ© = "ğŸ»ğŸ’³ğŸ›ï¸" (Bear + Debt + Stable)
##   |111âŸ© = "ğŸ»ğŸ’³ğŸšï¸" (Bear + Debt + Chaos) - crash state
##
## Commodity Trading (Generic):
##   - Commodities injected dynamically to bath (any emoji)
##   - Price = Hamiltonian tunneling rate (commodity â†’ money states)
##   - Trading = Lindblad drives (injection â†’ evolution â†’ extraction)
##   - Market impact = backaction on sentiment qubit
##
## Physics:
##   - Emergent pricing from spectral overlap
##   - Lindblad-driven exchange (trace conserving)
##   - Detuning modulation (sentiment affects price)
##   - Liquidity crises (trace limits money extraction)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONSTANTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const BASE_PRICE = 1.0  # Base Hamiltonian coupling strength
const SENTIMENT_CYCLE_PERIOD = 60.0  # seconds for bull/bear oscillation
const TRADE_DRIVE_RATE = 5.0  # Lindblad rate for trading
const LARGE_TRADE_THRESHOLD = 100  # Credits threshold for market impact
const MARKET_IMPACT_STRENGTH = 0.05  # Backaction on sentiment
const MARKET_LIQUIDITY_POOL = 10000  # Total market money capacity
const GAMMA_SQUARED = 1.0  # Detuning broadening factor

# Hamiltonian coupling strengths (modulate base price)
const BULL_BOOST = 1.5  # Price multiplier in bull markets
const BEAR_DISCOUNT = 0.5  # Price multiplier in bear markets
const CHAOS_PENALTY = 0.7  # Price reduction in chaotic markets
const STABLE_BONUS = 1.0  # No penalty in stable markets

# Icon decay rates
const CORE_DECAY_RATE = 0.02  # Natural market evolution
const COMMODITY_DECAY_RATE = 0.01  # Commodity spoilage

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STATE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Farm economy reference (set by Farm or FarmGrid)
var farm_economy = null

# Injected commodities (emojis currently tradeable)
var active_commodities: Array[String] = []

# Temporary trade drives (cleared after extraction)
var active_trade_drives: Dictionary = {}  # emoji -> {direction, rate}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INITIALIZATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func _ready():
	super._ready()

	# Configure visual properties for QuantumForceGraph
	visual_color = Color(1.0, 0.55, 0.0, 0.3)  # Sunset orange
	visual_label = "ğŸ“ˆ Market"
	visual_center_offset = Vector2(-1.15, -0.25)  # Top-left
	visual_oval_width = 400.0
	visual_oval_height = 250.0

	print("  âœ… MarketBiome v2 (Icon-Based) initializing...")


func _initialize_bath() -> void:
	"""Initialize quantum bath with 8 core market states (3-qubit tensor product)"""
	print("ğŸ› Initializing Market v2 quantum bath...")

	# Create bath with 8 core market states (3-char emoji labels)
	bath = QuantumBath.new()
	var core_emojis = [
		"ğŸ‚ğŸ’°ğŸ›ï¸",  # |000âŸ© Bull + Money + Stable (best)
		"ğŸ‚ğŸ’°ğŸšï¸",  # |001âŸ© Bull + Money + Chaos
		"ğŸ‚ğŸ’³ğŸ›ï¸",  # |010âŸ© Bull + Debt + Stable
		"ğŸ‚ğŸ’³ğŸšï¸",  # |011âŸ© Bull + Debt + Chaos
		"ğŸ»ğŸ’°ğŸ›ï¸",  # |100âŸ© Bear + Money + Stable
		"ğŸ»ğŸ’°ğŸšï¸",  # |101âŸ© Bear + Money + Chaos
		"ğŸ»ğŸ’³ğŸ›ï¸",  # |110âŸ© Bear + Debt + Stable
		"ğŸ»ğŸ’³ğŸšï¸",  # |111âŸ© Bear + Debt + Chaos (crash)
	]

	bath.initialize_with_emojis(core_emojis)

	# Initialize weighted distribution (neutral market, bias toward stability)
	bath.initialize_weighted({
		"ğŸ‚ğŸ’°ğŸ›ï¸": 0.20,  # Bull + Money + Stable (optimal)
		"ğŸ‚ğŸ’°ğŸšï¸": 0.05,  # Bull + Money + Chaos
		"ğŸ‚ğŸ’³ğŸ›ï¸": 0.10,  # Bull + Debt + Stable
		"ğŸ‚ğŸ’³ğŸšï¸": 0.02,  # Bull + Debt + Chaos
		"ğŸ»ğŸ’°ğŸ›ï¸": 0.20,  # Bear + Money + Stable
		"ğŸ»ğŸ’°ğŸšï¸": 0.05,  # Bear + Money + Chaos
		"ğŸ»ğŸ’³ğŸ›ï¸": 0.10,  # Bear + Debt + Stable
		"ğŸ»ğŸ’³ğŸšï¸": 0.28,  # Bear + Debt + Chaos (crash attractor)
	})

	# Create Icons for 8 core market states
	var market_icons = _create_core_market_icons()

	# Register Icons in IconRegistry
	var icon_registry = get_node("/root/IconRegistry")
	if not icon_registry:
		push_error("ğŸ› IconRegistry not available!")
		return

	for icon in market_icons:
		icon_registry.register_icon(icon)

	# Build Hamiltonian and Lindblad operators
	bath.active_icons = market_icons
	bath.build_hamiltonian_from_icons(market_icons)
	bath.build_lindblad_from_icons(market_icons)

	print("  âœ… Market core bath initialized: 8 states")
	print("  âœ… Hamiltonian: %d non-zero terms" % bath.hamiltonian_sparse.size())
	print("  âœ… Lindblad: %d transfer terms" % bath.lindblad_terms.size())
	print("  ğŸ“ˆ Market ready for commodity trading!")


func _create_core_market_icons() -> Array[Icon]:
	"""Create Icons for 8 core market states with Hamiltonian couplings and decay"""
	var icons: Array[Icon] = []

	# Sentiment flip rate (bull â†” bear natural oscillation)
	const SENTIMENT_FLIP_RATE = 0.1

	# Liquidity oscillation (money â†” debt natural flow)
	const LIQUIDITY_FLOW_RATE = 0.2

	# Stability decay (order â†’ chaos entropy)
	const STABILITY_DECAY_RATE = 0.05

	# |000âŸ© = ğŸ‚ğŸ’°ğŸ›ï¸ (Bull + Money + Stable) - Optimal market state
	var bull_money_stable = Icon.new()
	bull_money_stable.emoji = "ğŸ‚ğŸ’°ğŸ›ï¸"
	bull_money_stable.display_name = "Bull Money Stable"
	bull_money_stable.hamiltonian_couplings = {
		"ğŸ»ğŸ’°ğŸ›ï¸": SENTIMENT_FLIP_RATE,  # Bull â†” Bear (qubit 0)
		"ğŸ‚ğŸ’³ğŸ›ï¸": LIQUIDITY_FLOW_RATE,  # Money â†” Debt (qubit 1)
	}
	bull_money_stable.decay_rate = STABILITY_DECAY_RATE
	bull_money_stable.decay_target = "ğŸ‚ğŸ’°ğŸšï¸"  # Stable â†’ Chaos
	icons.append(bull_money_stable)

	# |001âŸ© = ğŸ‚ğŸ’°ğŸšï¸ (Bull + Money + Chaos)
	var bull_money_chaos = Icon.new()
	bull_money_chaos.emoji = "ğŸ‚ğŸ’°ğŸšï¸"
	bull_money_chaos.display_name = "Bull Money Chaos"
	bull_money_chaos.hamiltonian_couplings = {
		"ğŸ»ğŸ’°ğŸšï¸": SENTIMENT_FLIP_RATE,
		"ğŸ‚ğŸ’³ğŸšï¸": LIQUIDITY_FLOW_RATE,
	}
	bull_money_chaos.decay_rate = CORE_DECAY_RATE
	bull_money_chaos.decay_target = "ğŸ»ğŸ’³ğŸšï¸"  # Chaos attracts toward crash
	icons.append(bull_money_chaos)

	# |010âŸ© = ğŸ‚ğŸ’³ğŸ›ï¸ (Bull + Debt + Stable)
	var bull_debt_stable = Icon.new()
	bull_debt_stable.emoji = "ğŸ‚ğŸ’³ğŸ›ï¸"
	bull_debt_stable.display_name = "Bull Debt Stable"
	bull_debt_stable.hamiltonian_couplings = {
		"ğŸ»ğŸ’³ğŸ›ï¸": SENTIMENT_FLIP_RATE,
		"ğŸ‚ğŸ’°ğŸ›ï¸": LIQUIDITY_FLOW_RATE,  # Debt â†” Money
	}
	bull_debt_stable.decay_rate = STABILITY_DECAY_RATE
	bull_debt_stable.decay_target = "ğŸ‚ğŸ’³ğŸšï¸"
	icons.append(bull_debt_stable)

	# |011âŸ© = ğŸ‚ğŸ’³ğŸšï¸ (Bull + Debt + Chaos)
	var bull_debt_chaos = Icon.new()
	bull_debt_chaos.emoji = "ğŸ‚ğŸ’³ğŸšï¸"
	bull_debt_chaos.display_name = "Bull Debt Chaos"
	bull_debt_chaos.hamiltonian_couplings = {
		"ğŸ»ğŸ’³ğŸšï¸": SENTIMENT_FLIP_RATE,
		"ğŸ‚ğŸ’°ğŸšï¸": LIQUIDITY_FLOW_RATE,
	}
	bull_debt_chaos.decay_rate = CORE_DECAY_RATE * 1.5
	bull_debt_chaos.decay_target = "ğŸ»ğŸ’³ğŸšï¸"  # Strong crash attractor
	icons.append(bull_debt_chaos)

	# |100âŸ© = ğŸ»ğŸ’°ğŸ›ï¸ (Bear + Money + Stable)
	var bear_money_stable = Icon.new()
	bear_money_stable.emoji = "ğŸ»ğŸ’°ğŸ›ï¸"
	bear_money_stable.display_name = "Bear Money Stable"
	bear_money_stable.hamiltonian_couplings = {
		"ğŸ‚ğŸ’°ğŸ›ï¸": SENTIMENT_FLIP_RATE,
		"ğŸ»ğŸ’³ğŸ›ï¸": LIQUIDITY_FLOW_RATE,
	}
	bear_money_stable.decay_rate = STABILITY_DECAY_RATE
	bear_money_stable.decay_target = "ğŸ»ğŸ’°ğŸšï¸"
	icons.append(bear_money_stable)

	# |101âŸ© = ğŸ»ğŸ’°ğŸšï¸ (Bear + Money + Chaos)
	var bear_money_chaos = Icon.new()
	bear_money_chaos.emoji = "ğŸ»ğŸ’°ğŸšï¸"
	bear_money_chaos.display_name = "Bear Money Chaos"
	bear_money_chaos.hamiltonian_couplings = {
		"ğŸ‚ğŸ’°ğŸšï¸": SENTIMENT_FLIP_RATE,
		"ğŸ»ğŸ’³ğŸšï¸": LIQUIDITY_FLOW_RATE,
	}
	bear_money_chaos.decay_rate = CORE_DECAY_RATE
	bear_money_chaos.decay_target = "ğŸ»ğŸ’³ğŸšï¸"
	icons.append(bear_money_chaos)

	# |110âŸ© = ğŸ»ğŸ’³ğŸ›ï¸ (Bear + Debt + Stable)
	var bear_debt_stable = Icon.new()
	bear_debt_stable.emoji = "ğŸ»ğŸ’³ğŸ›ï¸"
	bear_debt_stable.display_name = "Bear Debt Stable"
	bear_debt_stable.hamiltonian_couplings = {
		"ğŸ‚ğŸ’³ğŸ›ï¸": SENTIMENT_FLIP_RATE,
		"ğŸ»ğŸ’°ğŸ›ï¸": LIQUIDITY_FLOW_RATE,
	}
	bear_debt_stable.decay_rate = STABILITY_DECAY_RATE
	bear_debt_stable.decay_target = "ğŸ»ğŸ’³ğŸšï¸"
	icons.append(bear_debt_stable)

	# |111âŸ© = ğŸ»ğŸ’³ğŸšï¸ (Bear + Debt + Chaos) - CRASH STATE (absorbing)
	var crash_state = Icon.new()
	crash_state.emoji = "ğŸ»ğŸ’³ğŸšï¸"
	crash_state.display_name = "Market Crash"
	crash_state.hamiltonian_couplings = {
		"ğŸ‚ğŸ’³ğŸšï¸": SENTIMENT_FLIP_RATE * 0.5,  # Weak recovery
		"ğŸ»ğŸ’°ğŸšï¸": LIQUIDITY_FLOW_RATE * 0.3,  # Weak liquidity injection
	}
	crash_state.decay_rate = 0.0  # Absorbing state (no decay)
	icons.append(crash_state)

	return icons


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMMODITY INJECTION (Generic Trading System)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func inject_commodity(emoji: String) -> bool:
	"""Add commodity to market bath for trading.

	Creates Icon with Hamiltonian couplings to money states.
	Price emerges from coupling strength modulated by market state.

	Args:
	    emoji: Commodity emoji (e.g., "ğŸ”¥", "ğŸ’§", "ğŸ’¨", "ğŸ")

	Returns:
	    true if commodity was added successfully
	"""
	# Check if already injected
	if emoji in active_commodities:
		return true

	# Get IconRegistry
	var icon_registry = get_node("/root/IconRegistry")
	if not icon_registry:
		push_error("ğŸ“ˆ IconRegistry not available!")
		return false

	# Check if Icon already exists in registry
	var existing_icon = icon_registry.get_icon(emoji)
	if existing_icon:
		# Icon exists globally, add to bath
		bath.add_emoji_to_basis(emoji)
		bath.active_icons.append(existing_icon)
		active_commodities.append(emoji)

		# Rebuild operators to include new commodity
		bath.build_hamiltonian_from_icons(bath.active_icons)
		bath.build_lindblad_from_icons(bath.active_icons)

		print("ğŸ“ˆ Market: Injected existing commodity %s" % emoji)
		return true

	# Create new commodity Icon
	var commodity_icon = _create_commodity_icon(emoji)

	# Register in IconRegistry
	icon_registry.register_icon(commodity_icon)

	# Add to bath
	bath.add_emoji_to_basis(emoji)
	bath.active_icons.append(commodity_icon)
	active_commodities.append(emoji)

	# Rebuild operators
	bath.build_hamiltonian_from_icons(bath.active_icons)
	bath.build_lindblad_from_icons(bath.active_icons)

	print("ğŸ“ˆ Market: Injected new commodity %s (price emerges from dynamics)" % emoji)
	return true


func _create_commodity_icon(emoji: String) -> Icon:
	"""Create Icon for generic commodity with price couplings.

	Commodity couples to ALL money states (not debt states).
	Coupling strength = base price * market condition modifiers.

	Price emergence:
	  - High coupling to bull+stable â†’ high price
	  - Low coupling to bear+chaos â†’ low price
	  - Current price = weighted sum by state probabilities
	"""
	var icon = Icon.new()
	icon.emoji = emoji
	icon.display_name = "Commodity " + emoji

	# Hamiltonian couplings to money states (commodity â†” money exchange)
	# NO coupling to debt states (can't buy with debt)
	icon.hamiltonian_couplings = {
		"ğŸ‚ğŸ’°ğŸ›ï¸": BASE_PRICE * BULL_BOOST * STABLE_BONUS,     # Highest price
		"ğŸ‚ğŸ’°ğŸšï¸": BASE_PRICE * BULL_BOOST * CHAOS_PENALTY,    # Bull but chaotic
		"ğŸ»ğŸ’°ğŸ›ï¸": BASE_PRICE * BEAR_DISCOUNT * STABLE_BONUS,  # Bear but stable
		"ğŸ»ğŸ’°ğŸšï¸": BASE_PRICE * BEAR_DISCOUNT * CHAOS_PENALTY, # Lowest price
		# Debt states excluded: "ğŸ‚ğŸ’³ğŸ›ï¸", "ğŸ‚ğŸ’³ğŸšï¸", "ğŸ»ğŸ’³ğŸ›ï¸", "ğŸ»ğŸ’³ğŸšï¸"
	}

	# Commodity decays (spoilage if not traded)
	icon.decay_rate = COMMODITY_DECAY_RATE
	icon.decay_target = "ğŸ‚"  # Spoils to organic matter

	# No outgoing Lindblad initially (added during trading)
	icon.lindblad_outgoing = {}

	return icon


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EMERGENT PRICING (Spectroscopic Model)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func get_commodity_price(emoji: String) -> float:
	"""Calculate emergent price from Hamiltonian spectral overlap.

	Price = effective tunneling rate from commodity to money states.
	Weighted by current market state probabilities.

	Physics:
	    P = Î£_i Î©_i * P(money_state_i)

	Where:
	    Î©_i = Hamiltonian coupling to money state i
	    P(money_state_i) = current probability of that state

	Returns:
	    Price in credits per unit (emergent from quantum dynamics)
	"""
	# Check commodity is injected
	if not emoji in active_commodities:
		return 0.0

	# Get commodity Icon
	var icon_registry = get_node("/root/IconRegistry")
	var icon = icon_registry.get_icon(emoji)
	if not icon:
		return 0.0

	# Calculate weighted price (spectral overlap)
	var price = 0.0
	for money_state in icon.hamiltonian_couplings:
		var coupling = icon.hamiltonian_couplings[money_state]
		var state_prob = bath.get_probability(money_state)
		price += coupling * state_prob

	# Detuning correction (sentiment modulation)
	var detuning = _compute_detuning(emoji)
	var omega_eff = price / (1.0 + detuning * detuning / GAMMA_SQUARED)

	return max(0.1, omega_eff)  # Floor price to prevent zero


func _compute_detuning(emoji: String) -> float:
	"""Calculate energy detuning (affects price via spectral broadening).

	Detuning increases in bear markets (widens gap, lowers price).
	Detuning decreases in bull markets (narrows gap, raises price).

	Returns:
	    Detuning Î” (dimensionless)
	"""
	var sentiment = get_marginal_sentiment()  # P(ğŸ‚)

	# Bear market (low sentiment) â†’ high detuning â†’ low price
	# Bull market (high sentiment) â†’ low detuning â†’ high price
	var delta = 2.0 * (1.0 - sentiment)  # Range: 0 (bull) to 2 (bear)

	return delta


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MARGINAL PROBABILITIES (Qubit Queries)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func get_marginal_sentiment() -> float:
	"""P(ğŸ‚) = sum of all states with ğŸ‚ in first position.

	Returns:
	    Bull probability (0.0 = full bear, 1.0 = full bull)
	"""
	var bull_states = ["ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’°ğŸšï¸", "ğŸ‚ğŸ’³ğŸ›ï¸", "ğŸ‚ğŸ’³ğŸšï¸"]
	var prob = 0.0
	for state in bull_states:
		prob += bath.get_probability(state)
	return prob


func get_marginal_liquidity() -> float:
	"""P(ğŸ’°) = sum of all states with ğŸ’° in second position.

	Returns:
	    Money probability (0.0 = full debt, 1.0 = full liquidity)
	"""
	var money_states = ["ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’°ğŸšï¸", "ğŸ»ğŸ’°ğŸ›ï¸", "ğŸ»ğŸ’°ğŸšï¸"]
	var prob = 0.0
	for state in money_states:
		prob += bath.get_probability(state)
	return prob


func get_marginal_stability() -> float:
	"""P(ğŸ›ï¸) = sum of all states with ğŸ›ï¸ in third position.

	Returns:
	    Stability probability (0.0 = full chaos, 1.0 = full order)
	"""
	var stable_states = ["ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’³ğŸ›ï¸", "ğŸ»ğŸ’°ğŸ›ï¸", "ğŸ»ğŸ’³ğŸ›ï¸"]
	var prob = 0.0
	for state in stable_states:
		prob += bath.get_probability(state)
	return prob


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TRADING API (Lindblad-Driven Exchange)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func buy_resource(emoji: String, amount: int) -> bool:
	"""Player buys resource from Market (Lindblad trading).

	Phase A (Injection): Activate Lindblad drive |ğŸ’°âŸ© â†’ |emojiâŸ©
	Phase B (Evolution): Automatic via bath.evolve() in _process()
	Phase C (Extraction): Deduct credits, add commodity to economy

	Args:
	    emoji: Resource to buy (e.g., "ğŸ”¥", "ğŸ’§", "ğŸ’¨")
	    amount: Credits to spend

	Returns:
	    true if trade successful
	"""
	if not farm_economy:
		push_error("ğŸ“ˆ Market: No economy reference!")
		return false

	# Ensure commodity is injected
	if not emoji in active_commodities:
		inject_commodity(emoji)

	# Calculate price
	var price_per_unit = get_commodity_price(emoji)
	var units = int(amount / price_per_unit)
	if units <= 0:
		return false

	var actual_cost = int(units * price_per_unit)

	# Check player has money
	if farm_economy.get_resource("ğŸ’°") < actual_cost:
		print("âŒ Market: Not enough ğŸ’°! (have %d, need %d)" % [
			farm_economy.get_resource("ğŸ’°"), actual_cost])
		return false

	# Check liquidity
	if not _check_liquidity_available(actual_cost):
		print("âš ï¸ Market: Liquidity crisis! Not enough money in circulation.")
		return false

	# PHASE A: INJECTION
	# Activate Lindblad drives: money states â†’ commodity
	_activate_buy_drives(emoji, units)

	# PHASE C: EXTRACTION (after evolution in next frame)
	# Deduct money from player
	farm_economy.remove_resource("ğŸ’°", actual_cost, "market_purchase")

	# Add commodity to player
	farm_economy.add_resource(emoji, units, "market_purchase")

	print("ğŸ“ˆ Market: Bought %d %s for %d ğŸ’° (price: %.2f)" % [
		units, emoji, actual_cost, price_per_unit])

	# Market impact (backaction)
	if actual_cost > LARGE_TRADE_THRESHOLD:
		_apply_market_impact(-MARKET_IMPACT_STRENGTH)  # Large buy â†’ bull shift

	# Schedule drive cleanup
	_schedule_drive_cleanup(emoji)

	return true


func sell_resource(emoji: String, amount: int) -> bool:
	"""Player sells resource to Market (Lindblad trading).

	Phase A (Injection): Activate Lindblad drive |emojiâŸ© â†’ |ğŸ’°âŸ©
	Phase B (Evolution): Automatic via bath.evolve()
	Phase C (Extraction): Deduct commodity, add credits to economy

	Args:
	    emoji: Resource to sell (e.g., "ğŸ")
	    amount: Units to sell

	Returns:
	    true if trade successful
	"""
	if not farm_economy:
		push_error("ğŸ“ˆ Market: No economy reference!")
		return false

	# Ensure commodity is injected
	if not emoji in active_commodities:
		inject_commodity(emoji)

	# Check player has resource
	if farm_economy.get_resource(emoji) < amount:
		print("âŒ Market: Not enough %s! (have %d, need %d)" % [
			emoji, farm_economy.get_resource(emoji), amount])
		return false

	# Calculate reward
	var price_per_unit = get_commodity_price(emoji)
	var reward = int(amount * price_per_unit)

	# PHASE A: INJECTION
	# Activate Lindblad drives: commodity â†’ money states
	_activate_sell_drives(emoji, amount)

	# PHASE C: EXTRACTION
	# Deduct commodity from player
	farm_economy.remove_resource(emoji, amount, "market_sale")

	# Add money to player
	farm_economy.add_resource("ğŸ’°", reward, "market_sale")

	print("ğŸ“ˆ Market: Sold %d %s for %d ğŸ’° (price: %.2f)" % [
		amount, emoji, reward, price_per_unit])

	# Market impact (backaction)
	if amount > LARGE_TRADE_THRESHOLD:
		_apply_market_impact(+MARKET_IMPACT_STRENGTH)  # Large sell â†’ bear shift

	# Schedule drive cleanup
	_schedule_drive_cleanup(emoji)

	return true


func _activate_buy_drives(emoji: String, units: int) -> void:
	"""Activate Lindblad drives for buying: money â†’ commodity"""
	var icon_registry = get_node("/root/IconRegistry")
	var money_states = ["ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’°ğŸšï¸", "ğŸ»ğŸ’°ğŸ›ï¸", "ğŸ»ğŸ’°ğŸšï¸"]

	for money_state in money_states:
		var money_icon = icon_registry.get_icon(money_state)
		if money_icon:
			# Add temporary Lindblad transfer: money â†’ commodity
			money_icon.lindblad_outgoing[emoji] = TRADE_DRIVE_RATE * units / 100.0

	# Rebuild Lindblad operators
	bath.build_lindblad_from_icons(bath.active_icons)

	# Track active drive
	active_trade_drives[emoji] = {"direction": "buy", "units": units}


func _activate_sell_drives(emoji: String, units: int) -> void:
	"""Activate Lindblad drives for selling: commodity â†’ money"""
	var icon_registry = get_node("/root/IconRegistry")
	var commodity_icon = icon_registry.get_icon(emoji)
	var money_states = ["ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’°ğŸšï¸", "ğŸ»ğŸ’°ğŸ›ï¸", "ğŸ»ğŸ’°ğŸšï¸"]

	if commodity_icon:
		for money_state in money_states:
			# Add temporary Lindblad transfer: commodity â†’ money
			commodity_icon.lindblad_outgoing[money_state] = TRADE_DRIVE_RATE * units / 100.0

	# Rebuild Lindblad operators
	bath.build_lindblad_from_icons(bath.active_icons)

	# Track active drive
	active_trade_drives[emoji] = {"direction": "sell", "units": units}


func _schedule_drive_cleanup(emoji: String) -> void:
	"""Schedule cleanup of trade drives after evolution.

	Uses timer to clear drives after 0.5 seconds (enough for evolution).
	"""
	await get_tree().create_timer(0.5).timeout
	_clear_trade_drives(emoji)


func _clear_trade_drives(emoji: String) -> void:
	"""Clear temporary Lindblad drives after trade completion"""
	if not emoji in active_trade_drives:
		return

	var icon_registry = get_node("/root/IconRegistry")
	var trade_info = active_trade_drives[emoji]

	if trade_info["direction"] == "buy":
		# Clear money â†’ commodity drives
		var money_states = ["ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’°ğŸšï¸", "ğŸ»ğŸ’°ğŸ›ï¸", "ğŸ»ğŸ’°ğŸšï¸"]
		for money_state in money_states:
			var money_icon = icon_registry.get_icon(money_state)
			if money_icon and emoji in money_icon.lindblad_outgoing:
				money_icon.lindblad_outgoing.erase(emoji)

	elif trade_info["direction"] == "sell":
		# Clear commodity â†’ money drives
		var commodity_icon = icon_registry.get_icon(emoji)
		if commodity_icon:
			commodity_icon.lindblad_outgoing.clear()

	# Rebuild Lindblad operators
	bath.build_lindblad_from_icons(bath.active_icons)

	# Remove from active drives
	active_trade_drives.erase(emoji)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MARKET IMPACT (Backaction on Sentiment)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func _apply_market_impact(sentiment_shift: float) -> void:
	"""Apply market impact via backaction on sentiment qubit.

	Large trades shift bull/bear probabilities.

	Args:
	    sentiment_shift > 0: Push toward bear (ğŸ»)
	    sentiment_shift < 0: Push toward bull (ğŸ‚)
	"""
	var icon_registry = get_node("/root/IconRegistry")
	var bull_states = ["ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’°ğŸšï¸", "ğŸ‚ğŸ’³ğŸ›ï¸", "ğŸ‚ğŸ’³ğŸšï¸"]
	var bear_states = ["ğŸ»ğŸ’°ğŸ›ï¸", "ğŸ»ğŸ’°ğŸšï¸", "ğŸ»ğŸ’³ğŸ›ï¸", "ğŸ»ğŸ’³ğŸšï¸"]

	# Add temporary Lindblad transfers
	for i in range(4):
		var bull_icon = icon_registry.get_icon(bull_states[i])
		var bear_icon = icon_registry.get_icon(bear_states[i])

		if sentiment_shift > 0:
			# Push toward bear: bull â†’ bear
			if bull_icon:
				bull_icon.lindblad_outgoing[bear_states[i]] = abs(sentiment_shift)
		else:
			# Push toward bull: bear â†’ bull
			if bear_icon:
				bear_icon.lindblad_outgoing[bull_states[i]] = abs(sentiment_shift)

	# Rebuild operators
	bath.build_lindblad_from_icons(bath.active_icons)

	# Clear impact after 1 second
	await get_tree().create_timer(1.0).timeout
	_clear_market_impact()


func _clear_market_impact() -> void:
	"""Clear temporary market impact drives"""
	var icon_registry = get_node("/root/IconRegistry")
	var all_core_states = [
		"ğŸ‚ğŸ’°ğŸ›ï¸", "ğŸ‚ğŸ’°ğŸšï¸", "ğŸ‚ğŸ’³ğŸ›ï¸", "ğŸ‚ğŸ’³ğŸšï¸",
		"ğŸ»ğŸ’°ğŸ›ï¸", "ğŸ»ğŸ’°ğŸšï¸", "ğŸ»ğŸ’³ğŸ›ï¸", "ğŸ»ğŸ’³ğŸšï¸"
	]

	for state in all_core_states:
		var icon = icon_registry.get_icon(state)
		if icon:
			# Clear any bullâ†”bear transfers (keep only base couplings)
			var to_remove = []
			for target in icon.lindblad_outgoing:
				if target in all_core_states:
					to_remove.append(target)
			for target in to_remove:
				icon.lindblad_outgoing.erase(target)

	bath.build_lindblad_from_icons(bath.active_icons)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LIQUIDITY CRISIS (Trace Conservation)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func _check_liquidity_available(amount: int) -> bool:
	"""Check if market has enough liquidity for trade.

	Total market money = P(ğŸ’°) * MARKET_LIQUIDITY_POOL

	Args:
	    amount: Credits needed for trade

	Returns:
	    true if enough liquidity exists
	"""
	var money_prob = get_marginal_liquidity()
	var available_money = int(money_prob * MARKET_LIQUIDITY_POOL)

	return available_money >= amount


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MARKET STATUS (Query API)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

func get_market_status() -> Dictionary:
	"""Get full market state for UI display"""
	return {
		"sentiment": get_marginal_sentiment(),
		"sentiment_label": _get_sentiment_label(),
		"liquidity": get_marginal_liquidity(),
		"stability": get_marginal_stability(),
		"crash_probability": bath.get_probability("ğŸ»ğŸ’³ğŸšï¸"),
		"active_commodities": active_commodities.size(),
		"liquidity_pool": int(get_marginal_liquidity() * MARKET_LIQUIDITY_POOL),
	}


func _get_sentiment_label() -> String:
	"""Convert sentiment probability to human label"""
	var sentiment = get_marginal_sentiment()
	if sentiment > 0.7:
		return "ğŸ‚ Strong Bull"
	elif sentiment > 0.5:
		return "ğŸ‚ Mild Bull"
	elif sentiment > 0.3:
		return "ğŸ» Mild Bear"
	else:
		return "ğŸ» Strong Bear"


func get_biome_type() -> String:
	"""Return biome type identifier"""
	return "Market"
